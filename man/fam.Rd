% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/fam-main.R
\name{fam}
\alias{fam}
\title{A functional additive model, for estimating main effects}
\usage{
fam(y, X1D = NULL, Xsc = NULL, nbasis = NULL, rho.grid = c(0.1,
  0.2, 0.3), eps = 0.05, max.iter = 20, cd.eps = 0.005,
  cd.max.iter = 100, lambda.grid = seq(0.05, 0.25, length.out = 10),
  type = "AIC", warm.start = TRUE, warm.start.rho = 0.1,
  warm.start.lam = 0.15, sim.ini = TRUE, linear.link = NULL,
  trace = FALSE, plots = TRUE, scale.X = TRUE, sparse.coef = TRUE,
  pve = 0.99)
}
\arguments{
\item{y}{treatment outcomes, n-by-1 vector}

\item{X1D}{a list of p pretreatment functional regressors; each of the functional regressors is evaluated on a grid (in [0,1]), giving a matrix (or a data.frame)}

\item{Xsc}{a matrix of q pretreatment scalar-regressors, n-by-q matrix (or a n-by-q data.frame)}

\item{nbasis}{an interger value specifying the number of B-spline basis funtions for approximating the link functions; the default is \code{nbasis.t=NULL}, and will be determined depending on the sample size.}

\item{rho.grid}{a grid vector of (ridge-type) smoothing parameters the p-splines in the link function estimation}

\item{eps}{a value specifying the convergence criterion of algorithm for estimating coef (linear prjections associated with the functional regressors)}

\item{max.iter}{an integer value specifying the maximum number of iterations for estimating coef (linear prjections associated with the functional regressors)}

\item{cd.eps}{a value specifying the convergence criterion of coordinate descent algorithm for estimating the link functions}

\item{cd.max.iter}{an integer value specifying the maximum number of coordinate descent iterations for estimating the link funtions}

\item{lambda.grid}{a grid of the sparsity tuning parameters, \code{lambda}, used in the \eqn{L1} regularization.}

\item{type}{can choose bewteen \code{"AIC"}, \code{"BIC"}, and \code{"GCV"}, for the sparsity tuninig parameter selection.}

\item{warm.start}{if \code{TRUE}, fit a \code{mim} with some given penalty parameters to obtain a reasonable starting value for the index coeffiicent vectors.}

\item{warm.start.rho}{a smoothness penalty to be used in obtaining an initial estimate.}

\item{warm.start.lam}{a sparsity penalty to be used in obtaining an initial estimate.}

\item{sim.ini}{if \code{TRUE}, use a single-index model estimate as an initial estimate of the index coefficient vector.}

\item{linear.link}{a length (p+q) vector of 1's or 0's, indicating whether to restrict the jth link functions to be linear or not; if \code{NULL}, will take the vector of 0's.}

\item{trace}{if \code{TRUE}, show the trace of the fitting procedure; the default is \code{FALSE}.}

\item{plots}{if \code{TRUE}, produce plots of the estiamated link functions and the estiamated coefficient functions}

\item{scale.X}{if \code{TRUE}, scale the FPC scores to have a unit variance and perform estimation (and will be scaled back in the final estimate)}

\item{sparse.coef}{if \code{TRUE}, estimate spasre coef vectors associated with the FPC scores, using lasso with \code{glmnet}; the default is \code{FALSE}.}

\item{pve}{the proportion of variance explained in determining the number of FPCs for the functional regressors}
}
\value{
a list of information of the fitted model including
\item{mim.obj}{a \code{mim} (a multiple-index model) object containing information about the fitted main-effect model, based on the FPC (scalar) scores and the scalar regressors.}
\item{scale.param}{a length (p+q) vector representing the scale parameters associated with the (p+q) regression component functions; 0 indicates the associated component function is shrinked to 0 (due to the L1 regularization).}
\item{scale.param.path}{a path of \code{scale.param} over a decreasing sequence of the sparsity parameters, \code{lambda}.}
\item{lambda.opt}{a value indicating the estimated optimal sparsity parameter, \code{lambda}.}
\item{coef}{a length p list of the estimated coef (the linear projection coefficients) associated with the FPC scores.}
\item{link.fn.fit}{a list of information about the estimated (p+q) link functions, including the knot sequences used in the B-spline approximations.}
\item{beta.0.coef}{a list of the estimated B-spline coefficient vectors associated with the (p+q) link functions.}
\item{smoother}{an object containing information about the estimated link functions, including the knot sequences used in the B-spline approximation \code{knots.t.}}
\item{coef.fn}{a length p list of the estimated coefficient functions associated with the unctional regressors.}
\item{eigen.fn}{a length p list of the matrices of eigenfunctions associated with the p functional regressors.}
\item{mean.fn}{a length p list of the mean functions associated with the p functional regressors.}
\item{rho.opt}{a length (p+q) vector of the estimated optimal penalty parameters used in the P-splines, associated with the (p+q) link functions}
\item{link.fn.plot}{a plot object for the (p+q) link functions.}
\item{coef.fn.plot}{a plot object for the p coefficient functions.}
}
\description{
\code{fam} is the main function for fitting the functional additive model (FAM) of Fan et al. (2015).
\code{fam} uses functional regressors, X1D, and scalar regressors, Xsc, for modeling a scalar-valued outcome y.
For each of the functional regressors, \code{fam} reduces its dimension via a data-driven linear projection to define a scalar-valued index variable,
and fits an additive model over those index variables and the scalar regressors simultaneousely.
For simultaneous variable selection, \code{fam} estimates a sparse combination of the components of the additive model via a \eqn{L1} regularization.
}
\details{
The sequence of the model coefficients implied by the tuning paramters \code{lambda} is fit by a coordinate descent algorithm.
}
\examples{
## generate a dataset
dat <- dataGnFn(n=300, p=10, q=3, contrast ="nonlinear")
y <- dat$y   # a vector of scalar-valued outcomes
X1D <- dat$X  # a list of 1-D functional regressors
Xsc <- dat$Z  # a matrix of scalar regressors

lambda.grid <- seq(0.1, 0.25, length.out = 10);  # a grid of tuning parameters for variable selection
fam.obj <- fam(y=y, X1D=X1D, Xsc=Xsc, lambda.grid=lambda.grid, type="AIC", sim.ini = TRUE,  sparse.coef=FALSE)
fam.obj$lambda.opt
#fam.obj$coef  # coefficient associated with the functoinal covariates
fam.obj$scale.param   # the shrinkage factors:  0 indicates that the corresponding variale is unselected
#fam.obj$scale.param.path
fam.obj$link.fn.plot[[1]]
fam.obj$coef.fn.plot[[1]]
}
\seealso{
\code{pred.fam},  \code{mim},  \code{cfam}
}
\author{
Park, Petkova, Tarpey, Ogden
}
